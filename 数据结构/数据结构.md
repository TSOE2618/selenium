# 数据结构与算法复习

## 一、数据结构绪论

## 基本概念与术语

- 数据：描述客观事物的符号，计算机中可操作的对象，**能被计算机识别并输入给计算机处理**的符号合集
- 数据元素：组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理，也被称为记录，比如人类这个集合中人就是数据元素。
- 数据项：一个数据元素可以由多个数据项组成，**数据项是数据不可分割的最小单位**。
- 数据对象：性质相同的数据元素的集合，是数据的子集
- **数据结构**：相互之间存在一种或多种特定关系的数据元素的集合。

## 逻辑结构与物理结构

- 逻辑结构：数据对象中元素之间的相互关系。

  

  - 集合结构：除了属于同一个集合外没有其他关系，如下图![](C:\Users\Rui\AppData\Roaming\Typora\typora-user-images\image-20210725120303937.png)

  - 线性结构:线性结构中元素是一对一的关系，特点是开始元素与终端元素都是唯一的，其余元素的前驱元素与后继元素都有且只有一个

  - 树形结构：树形结构中元素存在一对多的关系，二叉树是一种典型的树形结构

  - 图形结构：图形结构中元素是多对多的关系。

    

- 物理结构（存储结构）：

  - 顺序存储结构:把数据元素放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的

    ![image-20210725121022487](C:\Users\Rui\AppData\Roaming\Typora\typora-user-images\image-20210725121022487.png)

  - 链式存储结构：把数据元素存放到任意的存储单元里，这组存储单元可以连续也可以不连续。需要一个指针存放数据元素的地址。

- **逻辑结构面向问题，物理结构面向计算机，基本目标是将数据及其逻辑关系存储到计算机中的内存里**

- 抽象数据类型：

  - 

  - 数据类型：指一组性质相同的集合以及定义在此集合上的一些操作的总称。在C语言中，分为以下两类
    - 原子类型：不可以再分解的基本类型，包括整型、实型、字符型。
    - 结构类型：由数个类型组合而成，可以进行分解。

  - 抽象：**抽取事物具有的普遍性质**，抽出特征而忽略非本质的细节，可以理解为对具体事物的概括。
  - 抽象数据类型：**一个数学模型及定义在该模型上的一组操作**，抽象数据类型体现了程序设计中问题分解、抽象和信息隐藏的特性。

  

- 

  

  

  

  

  

  

  



## 二、算法基本概念





1. **算法是求解特点问题步骤的描述**，在计算机张表现为指令的有限序列，并且每条指令都表示一个或多个操作。

2. 算法特点：输入、输出、有穷性、确定性、可行性

3. 算法设计的要求

   - 正确性：指算法至少应该有输入、输出和加工处理无歧义、能正确放映问题的需求，能够得到问题的正确答案。
   - 可读性：便于阅读，理解和交流
   - 健壮性：当输入数据不合理时，算法应该也要能做出相应的处理，而不是报错或者产生错误的结果
   - 时间效率高和存储量低

4. 算法效率的度量

   - 事后统计法，利用设计好的测试程序和数据，用计算机计时器对不同算法编制的程序运行时间进行比较。
   - 事前估算：在计算机程序编制前，依据统计方法对算法进行估算
     - 运行时间依赖于算法好坏与输入规模
     - 判断一个算法的效率时，函数中的常数和其他次项往往可以忽略，更应该关注最高次项的阶数。

5. 算法时间复杂度：

   进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析(n)随n的变化情况并确定T(n)的数量级。算法的时间复杂度记作:T(n)=O(f(n))，它表示随问题规模n的增大，算法执行时间的增长率和f(n)相同称作算法的渐进时间复杂度。

   > 推导大O阶
   >
   > 1.用常数1取代运行时间中的所有加法常数
   >
   > 2.在修改后的运行次数函数中，只保留最高阶项。
   >
   > 3.如果最高阶项存在且不是1，则去除与这个项相乘的常数
   >
   > 最终得到的结果就是大O阶。

   **循环的时间复杂度等于循环体的复杂度乘以该循环运行的次数。**

   常见时间复杂度及其术语

   | 执行函数次数     | 阶         | 非正式术语 |
   | ---------------- | ---------- | ---------- |
   | $12$             | $O(1)$     | 常数阶     |
   | $2n+3$           | $O(n)$     | 线性阶     |
   | $3n^2+2n+1$      | $O(1)$     | 平方阶     |
   | $5log_2n +20$    | $O(logn)$  | 对数阶     |
   | $2n+3nlog_2n+19$ | $O(nlogn)$ | $nlogn$阶  |
   | $n^3 + 2n^2+1$   | $O(n^3)$   | 立方阶     |
   | $2^n$            | $O(2^n)$   | 指数阶     |

   其中，$O(1)<O(log(n))<O(n)<O(nlog(n))<O(n^2) <O(2^n)<O(n!) < O(n^n)$

   

6. 最坏情况与平均情况

   - 最坏情况运行时间是一种保证，那就是运行时间不会再坏了。在应用中，这是一种最重要的需求，通常情况下所提到的运行时间都是最坏情况的运行时间。
   - 平均运行时间是计算所有情况的平均值，平均运行时间是所有情况中最有意义的，因为它是期望的运行时间，平均运行时间很难通过分析得到，一般都是通过运行一定数量的实验数据后估算出来的。

7. 算法空间复杂度

   - 算法的空间复杂度是通过计算算法所需的存储空间实现的，算法空间复杂度的计算公式记作：$S(n)=O(f(n))$,其中，$n$为问题的规模，$f(n)$为语句关于$n$​​​所占用存储空间的函数。

     

   

## 三、线性表

1. 线性表的定义：**零个或多个数据元素的有限序列**

   - 有限
   - 序列（按顺序）

2. 线性表的抽象数据类型：

   > ADT 线性表（List）
   >
   > Data
   >
   > ​		线性表的数据对象集合为${a_1,a_2,…a_n}$,每个元素的类型为均为DataType。其中，除第一个元素$a_1$外，每一个元素有且只有一个直接前驱元素，除最后一个元素$a_n$外，每一个元素有且只有一个直接后继元素。数据元素之间的关系是一对一的关系。
   >
   > Operation
   >
   > ​		InitList(*L): 初始化操作，建立一个空的线性表L
   >
   > ​		ListEmpty(L):若线性表为空，则返回true，否则返回false.
   >
   > ​		ClearList(*L):将线性表清空。
   >
   > ​		GetElem(L,i,*e):将线性表L的第i个元素返回给e
   >
   > ​		LocateElem(L,e):在线性标注查找值与e相等的元素，查找成功返回该元素在表中的序号；否则返回0表示失败；
   >
   > ​		ListInsert(*L,i,e):在线性表中的第i个位置插入新元素e
   >
   > ​		ListDelete(*L,i,e):删除线性表中第i个位置元素，并用e返回其值
   >
   > ​		List Length(*L):返回线性表L的元素个数
   >
   > endADT

   以上基本操作可以组合成更复杂的操作，比如：A、B两个线性表，将B表中所包含的A表中所不存在的元素插入到A中，，即求两个表的并。

3. 线性表的存储结构

   - 顺序存储：用一段地址连续的存储单元以此存储线性表的数据元素，如下图所示

     ![image-20210725155212297](C:\Users\Rui\AppData\Roaming\Typora\typora-user-images\image-20210725155212297.png)

   - 顺序存储方式：

     ```C
     #define MAXSIZE 20 /*存储空间初始分配量*/
     typedef int Elemtype;/*ElemType类型根据实际情况而定，这里假设为int*/
     typedef struct
     {
         ElemType data[MAXSIZE]; /*数组存储数据元素，最大值为MAXSIZE*/
         int length; /*线性表当前长度*/
     }SqList;
     ```

     顺序存储需要三个属性:

     - 存储空间的其实位置：数组data，它的存储位置就是存储空间的存储位置。
     - 线性表的最大容量：数组长度MaxSize
     - 线性表的当前长度：length

4. 数据长度与线性表长度：

   - 数组长度：存放线性表的存储空间的长度

   - 线性表的长度是线性表中数据元素的个数

     其中 线性表长度<数组长度

5. 地址计算方法：

   - C中的数组是从0开始作为第一个下标，于是线性表的第$i$个元素要存储在数组下标为$i-1$的位置![image-20210725161225285](C:\Users\Rui\AppData\Roaming\Typora\typora-user-images\image-20210725161225285.png)

   - 存储器中的每个存储单元都有自己的编号，此即为地址。每个数据元素需要占据一定的存储单元空间。假设每个数据元素占用$c$个存储单元，那么线性表中第$i+1$个数据元素的存储位置如下式所示：

     > $Loc(a_(i+1))=Loc(a_i)+c$​
     >
     > $Loc(a_i)=Loc(a_1)+(i-1)*c$​
     >
     > ![image-20210725162010823](C:\Users\Rui\AppData\Roaming\Typora\typora-user-images\image-20210725162010823.png)

     

6. 顺序存储结构的插入与删除

   - 

7. 

























​       





